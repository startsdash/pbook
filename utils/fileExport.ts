
import { Prompt, PromptComponent, VerificationStatus } from '../types';
import * as XLSX from 'xlsx';

/**
 * Converts a Prompt object into a formatted Markdown string.
 */
export const generateMarkdown = (prompt: Prompt): string => {
  const date = new Date().toLocaleDateString('ru-RU');
  const statusLabel = prompt.verificationStatus === 'VERIFIED' ? 'âœ… ÐŸÑ€Ð¾Ð²ÐµÑ€ÐµÐ½Ð¾' : 'â³ ÐÐ° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐµ';
  
  return `# ${prompt.title}

> ${prompt.description}

---

## ðŸ“‹ ÐœÐµÑ‚Ð°Ð´Ð°Ð½Ð½Ñ‹Ðµ
- **ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ**: ${prompt.category}
- **Ð¢ÐµÐ³Ð¸**: ${prompt.tags.join(', ')}
- **Ð¡Ñ‚Ð°Ñ‚ÑƒÑ**: ${statusLabel}
- **Ð”Ð°Ñ‚Ð° ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°**: ${date}

---

## ðŸ¤– System Instruction
\`\`\`text
${prompt.systemContent || '(ÐŸÑƒÑÑ‚Ð¾)'}
\`\`\`

---

## ðŸ‘¤ User Prompt
\`\`\`text
${prompt.userContent || '(ÐŸÑƒÑÑ‚Ð¾)'}
\`\`\`

---
*Generated by Prompt Book*
`;
};

/**
 * Triggers a browser download for the given content.
 */
export const downloadFile = (filename: string, content: string, contentType: string) => {
  const blob = new Blob([content], { type: contentType });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';
  
  document.body.appendChild(link);
  link.click();
  
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

export const exportPromptToMarkdown = (prompt: Prompt) => {
  const content = generateMarkdown(prompt);
  const filename = `${prompt.title.replace(/\s+/g, '_')}_prompt.md`;
  downloadFile(filename, content, 'text/markdown');
};

export const exportPromptToJson = (prompt: Prompt) => {
  const content = JSON.stringify(prompt, null, 2);
  const filename = `${prompt.title.replace(/\s+/g, '_')}_data.json`;
  downloadFile(filename, content, 'application/json');
};

// --- Excel Functions ---

interface ExcelPromptRow {
    ID: string;
    Title: string;
    Category: string;
    Tags: string;
    Description: string;
    SystemContent: string;
    UserContent: string;
    VerificationStatus: string;
    ComponentsJSON: string; // Serialized JSON
    StructureID: string;
}

export const exportPromptsToExcel = (prompts: Prompt[]) => {
    // Flatten data for Excel
    const rows: ExcelPromptRow[] = prompts.map(p => ({
        ID: p.id,
        Title: p.title,
        Category: p.category,
        Tags: p.tags.join(', '),
        Description: p.description,
        SystemContent: p.systemContent,
        UserContent: p.userContent,
        VerificationStatus: p.verificationStatus,
        ComponentsJSON: JSON.stringify(p.components),
        StructureID: p.structureId || ''
    }));

    const worksheet = XLSX.utils.json_to_sheet(rows);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Prompts");

    // Auto-width for columns (rudimentary)
    const wscols = [
        {wch: 10}, // ID
        {wch: 30}, // Title
        {wch: 15}, // Category
        {wch: 20}, // Tags
        {wch: 40}, // Description
        {wch: 50}, // System
        {wch: 50}, // User
        {wch: 15}, // Status
    ];
    worksheet['!cols'] = wscols;

    XLSX.writeFile(workbook, `PromptDatabase_${new Date().toLocaleDateString('ru-RU')}.xlsx`);
};

export const parseExcelDatabase = async (file: File): Promise<Prompt[]> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = (e) => {
            try {
                const data = e.target?.result;
                const workbook = XLSX.read(data, { type: 'binary' });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const json = XLSX.utils.sheet_to_json<ExcelPromptRow>(worksheet);

                const prompts: Prompt[] = json.map(row => {
                    let parsedComponents: PromptComponent[] = [];
                    try {
                        parsedComponents = JSON.parse(row.ComponentsJSON);
                    } catch (e) {
                        console.warn('Failed to parse components for row', row.ID);
                    }

                    let status: VerificationStatus = 'ON_REVIEW';
                    if (row.VerificationStatus === 'VERIFIED') status = 'VERIFIED';

                    return {
                        id: row.ID ? String(row.ID) : Date.now().toString(),
                        title: row.Title || 'Ð‘ÐµÐ· Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ',
                        category: row.Category || 'Ð‘ÐµÐ· ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¸',
                        tags: row.Tags ? String(row.Tags).split(',').map(t => t.trim()).filter(Boolean) : [],
                        description: row.Description || '',
                        systemContent: row.SystemContent || '',
                        userContent: row.UserContent || '',
                        verificationStatus: status,
                        structureId: row.StructureID || undefined,
                        components: parsedComponents
                    };
                });
                
                resolve(prompts);
            } catch (err) {
                reject(err);
            }
        };
        
        reader.onerror = (err) => reject(err);
        reader.readAsBinaryString(file);
    });
};
