
import { Prompt, PromptComponent, Category } from '../types';
import * as XLSX from 'xlsx';

/**
 * Converts a Prompt object into a formatted Markdown string.
 */
export const generateMarkdown = (prompt: Prompt): string => {
  const date = new Date().toLocaleDateString('ru-RU');
  
  return `# ${prompt.title}

> ${prompt.description}

---

## ðŸ“‹ ÐœÐµÑ‚Ð°Ð´Ð°Ð½Ð½Ñ‹Ðµ
- **ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ**: ${prompt.category}
- **Ð¢ÐµÐ³Ð¸**: ${prompt.tags.join(', ')}
- **Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÐ¼Ð°Ñ Ð¼Ð¾Ð´ÐµÐ»ÑŒ**: ${prompt.modelRecommendation}
- **Ð”Ð°Ñ‚Ð° ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°**: ${date}

---

## ðŸ¤– System Instruction
\`\`\`text
${prompt.systemContent || '(ÐŸÑƒÑÑ‚Ð¾)'}
\`\`\`

---

## ðŸ‘¤ User Prompt
\`\`\`text
${prompt.userContent || '(ÐŸÑƒÑÑ‚Ð¾)'}
\`\`\`

${prompt.exampleOutput ? `---

## ðŸ’¡ ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð°
\`\`\`text
${prompt.exampleOutput}
\`\`\`
` : ''}

${prompt.notes ? `---

## ðŸ“ Ð—Ð°Ð¼ÐµÑ‚ÐºÐ¸
${prompt.notes}
` : ''}

---
*Generated by Prompt Book*
`;
};

/**
 * Triggers a browser download for the given content.
 */
export const downloadFile = (filename: string, content: string, contentType: string) => {
  const blob = new Blob([content], { type: contentType });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';
  
  document.body.appendChild(link);
  link.click();
  
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

export const exportPromptToMarkdown = (prompt: Prompt) => {
  const content = generateMarkdown(prompt);
  const filename = `${prompt.title.replace(/\s+/g, '_')}_prompt.md`;
  downloadFile(filename, content, 'text/markdown');
};

export const exportPromptToJson = (prompt: Prompt) => {
  const content = JSON.stringify(prompt, null, 2);
  const filename = `${prompt.title.replace(/\s+/g, '_')}_data.json`;
  downloadFile(filename, content, 'application/json');
};

// --- Excel Functions ---

interface ExcelPromptRow {
    ID: string;
    Title: string;
    Category: string;
    Tags: string;
    Description: string;
    SystemContent: string;
    UserContent: string;
    Model: string;
    Notes: string;
    ExampleOutput: string;
    ComponentsJSON: string; // Serialized JSON
    StructureID: string;
}

export const exportPromptsToExcel = (prompts: Prompt[]) => {
    // Flatten data for Excel
    const rows: ExcelPromptRow[] = prompts.map(p => ({
        ID: p.id,
        Title: p.title,
        Category: p.category,
        Tags: p.tags.join(', '),
        Description: p.description,
        SystemContent: p.systemContent,
        UserContent: p.userContent,
        Model: p.modelRecommendation,
        Notes: p.notes || '',
        ExampleOutput: p.exampleOutput || '',
        ComponentsJSON: JSON.stringify(p.components),
        StructureID: p.structureId || ''
    }));

    const worksheet = XLSX.utils.json_to_sheet(rows);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Prompts");

    // Auto-width for columns (rudimentary)
    const wscols = [
        {wch: 10}, // ID
        {wch: 30}, // Title
        {wch: 15}, // Category
        {wch: 20}, // Tags
        {wch: 40}, // Description
        {wch: 50}, // System
        {wch: 50}, // User
    ];
    worksheet['!cols'] = wscols;

    XLSX.writeFile(workbook, `PromptDatabase_${new Date().toLocaleDateString('ru-RU')}.xlsx`);
};

export const parseExcelDatabase = async (file: File): Promise<Prompt[]> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = (e) => {
            try {
                const data = e.target?.result;
                const workbook = XLSX.read(data, { type: 'binary' });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const json = XLSX.utils.sheet_to_json<ExcelPromptRow>(worksheet);

                const prompts: Prompt[] = json.map(row => {
                    let parsedComponents: PromptComponent[] = [];
                    try {
                        parsedComponents = JSON.parse(row.ComponentsJSON);
                    } catch (e) {
                        console.warn('Failed to parse components for row', row.ID);
                    }

                    // Map string back to Enum safely
                    let category: Category = Category.TEXT;
                    const catVal = Object.values(Category).find(c => c === row.Category);
                    if (catVal) category = catVal;

                    return {
                        id: row.ID ? String(row.ID) : Date.now().toString(),
                        title: row.Title || 'Ð‘ÐµÐ· Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ',
                        category: category,
                        tags: row.Tags ? String(row.Tags).split(',').map(t => t.trim()).filter(Boolean) : [],
                        description: row.Description || '',
                        systemContent: row.SystemContent || '',
                        userContent: row.UserContent || '',
                        modelRecommendation: row.Model || 'Gemini 2.5 Flash',
                        notes: row.Notes || '',
                        exampleOutput: row.ExampleOutput || '',
                        structureId: row.StructureID || undefined,
                        components: parsedComponents
                    };
                });
                
                resolve(prompts);
            } catch (err) {
                reject(err);
            }
        };
        
        reader.onerror = (err) => reject(err);
        reader.readAsBinaryString(file);
    });
};