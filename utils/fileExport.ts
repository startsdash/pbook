
import { Prompt, PromptComponent, VerificationStatus, Structure } from '../types';
import * as XLSX from 'xlsx';

/**
 * Converts a Prompt object into a formatted Markdown string.
 */
export const generateMarkdown = (prompt: Prompt): string => {
  const date = new Date().toLocaleDateString('ru-RU');
  const statusLabel = prompt.verificationStatus === 'VERIFIED' ? '‚úÖ –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ' : '‚è≥ –ù–∞ –ø—Ä–æ–≤–µ—Ä–∫–µ';
  
  return `# ${prompt.title}

> ${prompt.description}

---

## üìã –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: ${prompt.category}
- **–¢–µ–≥–∏**: ${prompt.tags.join(', ')}
- **–°—Ç–∞—Ç—É—Å**: ${statusLabel}
- **–î–∞—Ç–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞**: ${date}

---

## ü§ñ System Instruction
\`\`\`text
${prompt.systemContent || '(–ü—É—Å—Ç–æ)'}
\`\`\`

---

## üë§ User Prompt
\`\`\`text
${prompt.userContent || '(–ü—É—Å—Ç–æ)'}
\`\`\`

---
*Generated by Prompt Book*
`;
};

/**
 * Triggers a browser download for the given content.
 */
export const downloadFile = (filename: string, content: string, contentType: string) => {
  const blob = new Blob([content], { type: contentType });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';
  
  document.body.appendChild(link);
  link.click();
  
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

export const exportPromptToMarkdown = (prompt: Prompt) => {
  const content = generateMarkdown(prompt);
  const filename = `${prompt.title.replace(/\s+/g, '_')}_prompt.md`;
  downloadFile(filename, content, 'text/markdown');
};

export const exportPromptToJson = (prompt: Prompt) => {
  const content = JSON.stringify(prompt, null, 2);
  const filename = `${prompt.title.replace(/\s+/g, '_')}_data.json`;
  downloadFile(filename, content, 'application/json');
};

// --- Excel Functions ---

interface ExcelPromptRow {
    ID: string;
    Title: string;
    Category: string;
    Tags: string;
    Description: string;
    SystemContent: string;
    UserContent: string;
    VerificationStatus: string;
    ComponentsJSON: string; // Serialized JSON
    StructureID: string;
}

interface ExcelStructureRow {
    ID: string;
    Title: string;
    Description: string;
    ComponentsJSON: string; // Serialized JSON array of strings
}

interface ExcelSettingRow {
    Type: 'Category' | 'Tag';
    Value: string;
}

export const exportPromptsToExcel = (prompts: Prompt[], categories: string[], tags: string[], structures: Structure[]) => {
    // 1. Prepare Prompt Rows
    const promptRows: ExcelPromptRow[] = prompts.map(p => ({
        ID: p.id,
        Title: p.title,
        Category: p.category,
        Tags: p.tags.join(', '),
        Description: p.description,
        SystemContent: p.systemContent,
        UserContent: p.userContent,
        VerificationStatus: p.verificationStatus,
        ComponentsJSON: JSON.stringify(p.components || []),
        StructureID: p.structureId || ''
    }));

    // 2. Prepare Structure Rows
    const structureRows: ExcelStructureRow[] = structures.map(s => ({
        ID: s.id,
        Title: s.title,
        Description: s.description || '',
        ComponentsJSON: JSON.stringify(s.defaultComponents || [])
    }));

    const workbook = XLSX.utils.book_new();

    // Sheet 1: Prompts
    const promptWorksheet = XLSX.utils.json_to_sheet(promptRows);
    XLSX.utils.book_append_sheet(workbook, promptWorksheet, "Prompts");

    // Auto-width for columns
    promptWorksheet['!cols'] = [
        {wch: 15}, // ID
        {wch: 30}, // Title
        {wch: 20}, // Category
        {wch: 25}, // Tags
        {wch: 40}, // Description
        {wch: 50}, // System
        {wch: 50}, // User
        {wch: 15}, // Status
        {wch: 20}, // Components
        {wch: 15}, // StructureID
    ];

    // Sheet 2: Structures
    if (structureRows.length > 0) {
        const structureWorksheet = XLSX.utils.json_to_sheet(structureRows);
        XLSX.utils.book_append_sheet(workbook, structureWorksheet, "Structures");
        structureWorksheet['!cols'] = [
            {wch: 15}, // ID
            {wch: 30}, // Title
            {wch: 40}, // Description
            {wch: 40}, // ComponentsJSON
        ];
    }

    // Sheet 3: Settings (Categories & Tags)
    // Filter out '–í—Å–µ' from categories as it is a default UI constant
    const uniqueCats = Array.from(new Set(categories)).filter(c => c && c !== '–í—Å–µ');
    const uniqueTags = Array.from(new Set(tags));

    const settingsRows: ExcelSettingRow[] = [
        ...uniqueCats.map(c => ({ Type: 'Category' as const, Value: c })),
        ...uniqueTags.map(t => ({ Type: 'Tag' as const, Value: t }))
    ];

    if (settingsRows.length > 0) {
        const settingsWorksheet = XLSX.utils.json_to_sheet(settingsRows);
        XLSX.utils.book_append_sheet(workbook, settingsWorksheet, "Settings");
    }

    XLSX.writeFile(workbook, `PromptBook_DB_${new Date().toISOString().slice(0,10)}.xlsx`);
};

export const parseExcelDatabase = async (file: File): Promise<{ prompts: Prompt[], categories: string[], tags: string[], structures: Structure[] }> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = (e) => {
            try {
                const data = e.target?.result;
                if (!data) {
                    throw new Error("File content is empty");
                }

                // Use 'array' type for robustness across browsers
                const workbook = XLSX.read(data, { type: 'array' });
                
                // 1. Parse Prompts
                const sheetName = workbook.SheetNames.find(n => n === "Prompts") || workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const json = XLSX.utils.sheet_to_json<any>(worksheet);

                const prompts: Prompt[] = json.map((row: any) => {
                    let parsedComponents: PromptComponent[] = [];
                    try {
                        if (row.ComponentsJSON && row.ComponentsJSON !== 'undefined') {
                            parsedComponents = JSON.parse(String(row.ComponentsJSON));
                        }
                    } catch (e) {
                        console.warn('Failed to parse components for row', row.ID);
                    }

                    // Robust Status parsing (case insensitive)
                    let status: VerificationStatus = 'ON_REVIEW';
                    const statusStr = String(row.VerificationStatus || '').trim().toUpperCase();
                    if (statusStr === 'VERIFIED') status = 'VERIFIED';

                    // Parse tags carefully
                    const tagsRaw = row.Tags ? String(row.Tags) : '';
                    const tagsList = tagsRaw.split(',').map(t => t.trim()).filter(Boolean);

                    return {
                        id: row.ID ? String(row.ID) : Math.random().toString(36).substr(2, 9),
                        title: row.Title ? String(row.Title) : '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
                        category: row.Category ? String(row.Category) : '–ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏',
                        tags: tagsList,
                        description: row.Description ? String(row.Description) : '',
                        systemContent: row.SystemContent ? String(row.SystemContent) : '',
                        userContent: row.UserContent ? String(row.UserContent) : '',
                        verificationStatus: status,
                        structureId: row.StructureID ? String(row.StructureID) : undefined,
                        components: parsedComponents
                    };
                });

                // 2. Parse Structures
                let structures: Structure[] = [];
                if (workbook.SheetNames.includes("Structures")) {
                    const structSheet = workbook.Sheets["Structures"];
                    const structJson = XLSX.utils.sheet_to_json<any>(structSheet);
                    
                    structures = structJson.map((row: any) => {
                        let defaults: string[] = [];
                        try {
                             if (row.ComponentsJSON && row.ComponentsJSON !== 'undefined') {
                                defaults = JSON.parse(String(row.ComponentsJSON));
                             }
                        } catch (e) {
                            console.warn('Failed to parse structure components', row.ID);
                        }

                        return {
                            id: row.ID ? String(row.ID) : Date.now().toString(),
                            title: row.Title ? String(row.Title) : 'Imported Structure',
                            description: row.Description ? String(row.Description) : '',
                            defaultComponents: Array.isArray(defaults) ? defaults : []
                        };
                    });
                }

                // 3. Parse Settings (if available)
                let parsedCategories: string[] = [];
                let parsedTags: string[] = [];

                if (workbook.SheetNames.includes("Settings")) {
                    const settingsSheet = workbook.Sheets["Settings"];
                    const settingsJson = XLSX.utils.sheet_to_json<ExcelSettingRow>(settingsSheet);
                    
                    parsedCategories = settingsJson.filter(r => r.Type === 'Category').map(r => String(r.Value));
                    parsedTags = settingsJson.filter(r => r.Type === 'Tag').map(r => String(r.Value));
                }

                // 4. Merge with metadata found in prompts (recovery mode)
                // We use Sets to avoid duplicates, but strictly respect the "Settings" sheet if it exists to avoid tag/category confusion.
                const promptCategories = new Set(prompts.map(p => p.category));
                const promptTags = new Set(prompts.flatMap(p => p.tags));

                // Combine parsed settings with any categories/tags actually used in the prompts
                const finalCategories = Array.from(new Set([...parsedCategories, ...promptCategories])).filter(c => c && c !== '–í—Å–µ');
                const finalTags = Array.from(new Set([...parsedTags, ...promptTags])).filter(Boolean);

                resolve({ 
                    prompts, 
                    categories: ['–í—Å–µ', ...finalCategories], 
                    tags: finalTags,
                    structures 
                });
            } catch (err) {
                console.error("Excel parse error:", err);
                reject(err);
            }
        };
        
        reader.onerror = (err) => reject(err);
        reader.readAsArrayBuffer(file);
    });
};
