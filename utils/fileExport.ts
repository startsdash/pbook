
import { Prompt, PromptComponent, VerificationStatus, Structure, Template } from '../types';
import * as XLSX from 'xlsx';

/**
 * Converts a Prompt object into a formatted Markdown string.
 */
export const generateMarkdown = (prompt: Prompt): string => {
  const date = new Date().toLocaleDateString('ru-RU');
  const statusLabel = prompt.verificationStatus === 'VERIFIED' ? '‚úÖ –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ' : '‚è≥ –ù–∞ –ø—Ä–æ–≤–µ—Ä–∫–µ';
  
  return `# ${prompt.title}

> ${prompt.description}

---

## üìã –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: ${prompt.category}
- **–¢–µ–≥–∏**: ${prompt.tags.join(', ')}
- **–°—Ç–∞—Ç—É—Å**: ${statusLabel}
- **–î–∞—Ç–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞**: ${date}

---

## ü§ñ System Instruction
\`\`\`text
${prompt.systemContent || '(–ü—É—Å—Ç–æ)'}
\`\`\`

---

## üë§ User Prompt
\`\`\`text
${prompt.userContent || '(–ü—É—Å—Ç–æ)'}
\`\`\`

---
*Generated by Prompt Book*
`;
};

/**
 * Triggers a browser download for the given content.
 */
export const downloadFile = (filename: string, content: string, contentType: string) => {
  const blob = new Blob([content], { type: contentType });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';
  
  document.body.appendChild(link);
  link.click();
  
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

export const exportPromptToMarkdown = (prompt: Prompt) => {
  const content = generateMarkdown(prompt);
  const filename = `${prompt.title.replace(/\s+/g, '_')}_prompt.md`;
  downloadFile(filename, content, 'text/markdown');
};

export const exportPromptToJson = (prompt: Prompt) => {
  const content = JSON.stringify(prompt, null, 2);
  const filename = `${prompt.title.replace(/\s+/g, '_')}_data.json`;
  downloadFile(filename, content, 'application/json');
};

// --- Excel Functions ---

interface ExcelPromptRow {
    ID: string;
    Title: string;
    Category: string;
    Tags: string;
    Description: string;
    SystemContent: string;
    UserContent: string;
    VerificationStatus: string;
    ComponentsJSON: string; // Serialized JSON
    StructureID: string;
}

interface ExcelStructureRow {
    ID: string;
    Title: string;
    Description: string;
    ComponentsJSON: string; // Serialized JSON array of strings
}

interface ExcelSettingRow {
    Type: 'Category' | 'Tag';
    Value: string;
}

export const exportPromptsToExcel = (prompts: Prompt[], categories: string[], tags: string[], structures: Structure[], templates: Template[] = []) => {
    // Helper to format rows
    const formatPromptRow = (p: Prompt): ExcelPromptRow => ({
        ID: p.id,
        Title: p.title,
        Category: p.category,
        Tags: p.tags.join(', '),
        Description: p.description,
        SystemContent: p.systemContent,
        UserContent: p.userContent,
        VerificationStatus: p.verificationStatus,
        ComponentsJSON: JSON.stringify(p.components || []),
        StructureID: p.structureId || ''
    });

    // 1. Prepare Prompt Rows
    const promptRows: ExcelPromptRow[] = prompts.map(formatPromptRow);

    // 2. Prepare Template Rows
    const templateRows: ExcelPromptRow[] = templates.map(formatPromptRow);

    // 3. Prepare Structure Rows
    const structureRows: ExcelStructureRow[] = structures.map(s => ({
        ID: s.id,
        Title: s.title,
        Description: s.description || '',
        ComponentsJSON: JSON.stringify(s.defaultComponents || [])
    }));

    const workbook = XLSX.utils.book_new();

    // Sheet 1: Prompts
    const promptWorksheet = XLSX.utils.json_to_sheet(promptRows);
    XLSX.utils.book_append_sheet(workbook, promptWorksheet, "Prompts");

    const setCols = (ws: XLSX.WorkSheet) => {
        ws['!cols'] = [
            {wch: 15}, // ID
            {wch: 30}, // Title
            {wch: 20}, // Category
            {wch: 25}, // Tags
            {wch: 40}, // Description
            {wch: 50}, // System
            {wch: 50}, // User
            {wch: 15}, // Status
            {wch: 20}, // Components
            {wch: 15}, // StructureID
        ];
    };
    setCols(promptWorksheet);

    // Sheet 2: Templates
    if (templateRows.length > 0) {
        const templateWorksheet = XLSX.utils.json_to_sheet(templateRows);
        XLSX.utils.book_append_sheet(workbook, templateWorksheet, "Templates");
        setCols(templateWorksheet);
    }

    // Sheet 3: Structures
    if (structureRows.length > 0) {
        const structureWorksheet = XLSX.utils.json_to_sheet(structureRows);
        XLSX.utils.book_append_sheet(workbook, structureWorksheet, "Structures");
        structureWorksheet['!cols'] = [
            {wch: 15}, // ID
            {wch: 30}, // Title
            {wch: 40}, // Description
            {wch: 40}, // ComponentsJSON
        ];
    }

    // Sheet 4: Settings (Categories & Tags)
    const uniqueCats = Array.from(new Set(categories)).filter(c => c && c !== '–í—Å–µ');
    const uniqueTags = Array.from(new Set(tags));

    const settingsRows: ExcelSettingRow[] = [
        ...uniqueCats.map(c => ({ Type: 'Category' as const, Value: c })),
        ...uniqueTags.map(t => ({ Type: 'Tag' as const, Value: t }))
    ];

    if (settingsRows.length > 0) {
        const settingsWorksheet = XLSX.utils.json_to_sheet(settingsRows);
        XLSX.utils.book_append_sheet(workbook, settingsWorksheet, "Settings");
    }

    XLSX.writeFile(workbook, `PromptBook_DB_${new Date().toISOString().slice(0,10)}.xlsx`);
};

export const parseExcelDatabase = async (file: File): Promise<{ prompts: Prompt[], categories: string[], tags: string[], structures: Structure[], templates: Template[] }> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = (e) => {
            try {
                const data = e.target?.result;
                if (!data) {
                    throw new Error("File content is empty");
                }

                // Use 'array' type for robustness across browsers
                const workbook = XLSX.read(data, { type: 'array' });
                
                const parsePromptsFromSheet = (sheetName: string): Prompt[] => {
                    if (!workbook.SheetNames.includes(sheetName)) return [];
                    const worksheet = workbook.Sheets[sheetName];
                    const json = XLSX.utils.sheet_to_json<any>(worksheet);

                    return json.map((row: any) => {
                        let parsedComponents: PromptComponent[] = [];
                        try {
                            if (row.ComponentsJSON && row.ComponentsJSON !== 'undefined') {
                                parsedComponents = JSON.parse(String(row.ComponentsJSON));
                            }
                        } catch (e) {
                            console.warn('Failed to parse components for row', row.ID);
                        }

                        let status: VerificationStatus = 'ON_REVIEW';
                        const statusStr = String(row.VerificationStatus || '').trim().toUpperCase();
                        if (statusStr === 'VERIFIED') status = 'VERIFIED';

                        const tagsRaw = row.Tags ? String(row.Tags) : '';
                        const tagsList = tagsRaw.split(',').map(t => t.trim()).filter(Boolean);

                        return {
                            id: row.ID ? String(row.ID) : Math.random().toString(36).substr(2, 9),
                            title: row.Title ? String(row.Title) : '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
                            category: row.Category ? String(row.Category) : '–ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏',
                            tags: tagsList,
                            description: row.Description ? String(row.Description) : '',
                            systemContent: row.SystemContent ? String(row.SystemContent) : '',
                            userContent: row.UserContent ? String(row.UserContent) : '',
                            verificationStatus: status,
                            structureId: row.StructureID ? String(row.StructureID) : undefined,
                            components: parsedComponents
                        };
                    });
                };

                // 1. Parse Prompts
                const prompts = parsePromptsFromSheet("Prompts");

                // 2. Parse Templates
                const templates = parsePromptsFromSheet("Templates");

                // 3. Parse Structures
                let structures: Structure[] = [];
                if (workbook.SheetNames.includes("Structures")) {
                    const structSheet = workbook.Sheets["Structures"];
                    const structJson = XLSX.utils.sheet_to_json<any>(structSheet);
                    
                    structures = structJson.map((row: any) => {
                        let defaults: string[] = [];
                        try {
                             if (row.ComponentsJSON && row.ComponentsJSON !== 'undefined') {
                                defaults = JSON.parse(String(row.ComponentsJSON));
                             }
                        } catch (e) {
                            console.warn('Failed to parse structure components', row.ID);
                        }

                        return {
                            id: row.ID ? String(row.ID) : Date.now().toString(),
                            title: row.Title ? String(row.Title) : 'Imported Structure',
                            description: row.Description ? String(row.Description) : '',
                            defaultComponents: Array.isArray(defaults) ? defaults : []
                        };
                    });
                }

                // 4. Parse Settings (if available)
                let parsedCategories: string[] = [];
                let parsedTags: string[] = [];

                if (workbook.SheetNames.includes("Settings")) {
                    const settingsSheet = workbook.Sheets["Settings"];
                    const settingsJson = XLSX.utils.sheet_to_json<ExcelSettingRow>(settingsSheet);
                    
                    parsedCategories = settingsJson.filter(r => r.Type === 'Category').map(r => String(r.Value));
                    parsedTags = settingsJson.filter(r => r.Type === 'Tag').map(r => String(r.Value));
                }

                let finalCategories: string[] = [];
                if (parsedCategories.length > 0) {
                    finalCategories = parsedCategories;
                } else {
                    const promptCategories = new Set([...prompts, ...templates].map(p => p.category));
                    finalCategories = Array.from(promptCategories);
                }

                const promptTags = new Set([...prompts, ...templates].flatMap(p => p.tags));
                const finalTags = Array.from(new Set([...parsedTags, ...promptTags])).filter(Boolean);

                const uniqueCategories = Array.from(new Set(['–í—Å–µ', ...finalCategories]));

                resolve({ 
                    prompts, 
                    categories: uniqueCategories, 
                    tags: finalTags,
                    structures,
                    templates
                });
            } catch (err) {
                console.error("Excel parse error:", err);
                reject(err);
            }
        };
        
        reader.onerror = (err) => reject(err);
        reader.readAsArrayBuffer(file);
    });
};
